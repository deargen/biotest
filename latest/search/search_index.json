{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "]},"docs":[{"location":"","title":"biotest","text":"<p>A Python package for testing bioinformatics data. Mainly, it provides a set of functions to compare normal text/binary files, npy files, pdb files, and directories.</p>"},{"location":"#installation","title":"\ud83d\udee0\ufe0f Installation","text":"<pre><code>pip install biotest\n</code></pre>"},{"location":"#usage","title":"\ud83d\ude80 Usage","text":"<p>Mainly, use the API with pytest.</p> <pre><code>from biotest.compare_files import (\n    assert_two_files_equal_sha,\n    assert_two_npys_within_tolerance,\n    assert_two_pdbqt_files_within_tolerance,\n    assert_two_pdb_files_within_tolerance,\n    assert_two_dirs_within_tolerance,\n)\n\ndef assert_two_files_sha(file1: str | PathLike | IOBase, file2: str | PathLike | IOBase):\n    \"\"\"\n    Assert that two files are exactly the same.\n    \"\"\"\n    ...\n\ndef assert_two_npys_within_tolerance(\n    npy1: str | PathLike | np.ndarray, npy2: str | PathLike | np.ndarray, *, tolerance=1e-6\n):\n    \"\"\"\n    Assert that two npy files are almost the same within a tolerance.\n    \"\"\"\n    ...\n\n\ndef assert_two_pdbqt_files_within_tolerance(\n    file1: str | PathLike | IOBase, file2: str | PathLike | IOBase, *, tolerance=1e-3\n):\n    \"\"\"\n    Assert that two pdbqt files are equal under following conditions.\n\n    - ignore the trailing whitespace.\n    - 0.001 default tolerance for Orthogonal coordinates for X,Y,Z in Angstroms.\n    \"\"\"\n    ...\n\n\ndef assert_two_pdb_files_within_tolerance(\n    file1: str | PathLike | IOBase, file2: str | PathLike | IOBase, *, tolerance=1e-3\n):\n    \"\"\"\n    Assert that two pdb files are equal under following conditions.\n\n    - ignore the trailing whitespace.\n    - 0.001 default tolerance for Orthogonal coordinates for X,Y,Z in Angstroms.\n    \"\"\"\n    ...\n\n\ndef assert_two_dirs_within_tolerance(\n    dir1: str | PathLike,\n    dir2: str | PathLike,\n    *,\n    tolerance: float = 1e-3,\n    filenames_exclude: Sequence[str] | None = None,\n):\n    \"\"\"\n    Assert that two directories have the same files with almost the same content within tolerance.\n    \"\"\"\n    ...\n</code></pre> <p>Also, you can use the CLI to quickly test the functionality. These merely call the functions above, so they will print the traceback if the assertion fails.</p> <pre><code>biotest assert-two-files-equal-sha file1 file2\nbiotest assert-two-npys-within-tolerance file1.npy file2.npy\nbiotest assert-two-pdbqt-files-within-tolerance file1.pdbqt file2.pdbqt\nbiotest assert-two-pdb-files-within-tolerance file1.pdb file2.pdb\nbiotest assert-two-dirs-within-tolerance dir1 dir2\n</code></pre>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> biotest<ul> <li> cli<ul> <li> main</li> </ul> </li> <li> compare_files</li> <li> utils<ul> <li> config</li> <li> log</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/biotest/","title":"Index","text":""},{"location":"reference/biotest/compare_files/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> compare_files","text":""},{"location":"reference/biotest/compare_files/#biotest.compare_files.assert_two_files_equal_sha","title":"<code>assert_two_files_equal_sha(file1, file2)</code>","text":"<p>Assert that two files are exactly the same.</p> Source code in <code>src/biotest/compare_files.py</code> <pre><code>def assert_two_files_equal_sha(\n    file1: str | PathLike | IOBase, file2: str | PathLike | IOBase\n):\n    \"\"\"\n    Assert that two files are exactly the same.\n    \"\"\"\n    sha1 = hashlib.sha1()\n    sha2 = hashlib.sha1()\n    sha1.update(_read_file_or_io(file1, decode=False))\n    sha2.update(_read_file_or_io(file2, decode=False))\n\n    assert (\n        sha1.hexdigest() == sha2.hexdigest()\n    ), f\"{file1} and {file2} have different SHA1 hashes.\"\n</code></pre>"},{"location":"reference/biotest/compare_files/#biotest.compare_files.assert_two_npys_within_tolerance","title":"<code>assert_two_npys_within_tolerance(npy1, npy2, *, tolerance=1e-06)</code>","text":"<p>Assert that two npy files are almost the same within a tolerance.</p> Source code in <code>src/biotest/compare_files.py</code> <pre><code>def assert_two_npys_within_tolerance(\n    npy1: str | PathLike | np.ndarray,\n    npy2: str | PathLike | np.ndarray,\n    *,\n    tolerance=1e-6,\n):\n    \"\"\"\n    Assert that two npy files are almost the same within a tolerance.\n    \"\"\"\n    if isinstance(npy1, str | PathLike):\n        nparray1: np.ndarray = np.load(npy1)\n    else:\n        nparray1 = npy1\n    if isinstance(npy2, str | PathLike):\n        nparray2: np.ndarray = np.load(npy2)\n    else:\n        nparray2 = npy2\n\n    assert np.allclose(nparray1, nparray2, atol=tolerance, rtol=tolerance), (\n        f\"{npy1} and {npy2} have different data.\"\n        f\" {nparray1} and {nparray2} are not close.\"\n    )\n</code></pre>"},{"location":"reference/biotest/compare_files/#biotest.compare_files.assert_two_pdbqt_files_within_tolerance","title":"<code>assert_two_pdbqt_files_within_tolerance(file1, file2, *, tolerance=0.001)</code>","text":"<p>Assert that two pdbqt files are equal under following conditions.</p> <ul> <li>ignore the trailing whitespace.</li> <li>0.001 default tolerance for Orthogonal coordinates for X,Y,Z in Angstroms.</li> </ul> Source code in <code>src/biotest/compare_files.py</code> <pre><code>def assert_two_pdbqt_files_within_tolerance(\n    file1: str | PathLike | IOBase, file2: str | PathLike | IOBase, *, tolerance=1e-3\n):\n    \"\"\"\n    Assert that two pdbqt files are equal under following conditions.\n\n    - ignore the trailing whitespace.\n    - 0.001 default tolerance for Orthogonal coordinates for X,Y,Z in Angstroms.\n    \"\"\"\n    lines1 = _read_file_or_io(file1)\n    lines2 = _read_file_or_io(file1)\n\n    assert len(lines1) == len(lines2), f\"{file1} and {file2} have different lengths.\"\n\n    for line1, line2 in zip(lines1, lines2, strict=True):\n        if line1.rstrip() != line2.rstrip():\n            if line1.startswith(\"ATOM\") and line2.startswith(\"ATOM\"):\n                # Check for Orthogonal coordinates for X,Y,Z in Angstroms\n                # https://userguide.mdanalysis.org/stable/formats/reference/pdbqt.html\n                coord_1 = (\n                    float(line1[30:38]),\n                    float(line1[38:46]),\n                    float(line1[46:54]),\n                )\n                coord_2 = (\n                    float(line2[30:38]),\n                    float(line2[38:46]),\n                    float(line2[46:54]),\n                )\n\n                for c1, c2 in zip(coord_1, coord_2, strict=True):\n                    assert np.isclose(c1, c2, atol=tolerance), (\n                        f\"{file1} and {file2} have different lines.\"\n                        f\" {line1.rstrip()} and {line2.rstrip()} are not equal.\"\n                    )\n\n                line1_except_coord = line1[:30] + line1[54:]\n                line2_except_coord = line2[:30] + line2[54:]\n                assert line1_except_coord.rstrip() == line2_except_coord.rstrip(), (\n                    f\"{file1} and {file2} have different lines.\"\n                    f\" {line1.rstrip()} and {line2.rstrip()} are not equal.\"\n                )\n            else:\n                raise AssertionError(\n                    f\"{file1} and {file2} have different lines.\"\n                    f\" {line1.rstrip()} and {line2.rstrip()} are not equal.\"\n                )\n</code></pre>"},{"location":"reference/biotest/compare_files/#biotest.compare_files.assert_two_pdb_files_within_tolerance","title":"<code>assert_two_pdb_files_within_tolerance(file1, file2, *, tolerance=0.001)</code>","text":"<p>Assert that two pdb files are equal under following conditions.</p> <ul> <li>ignore the trailing whitespace.</li> <li>0.001 default tolerance for Orthogonal coordinates for X,Y,Z in Angstroms.</li> </ul> Note <ul> <li>Currently, the implementation is completely equal to assert_two_pdbqt_files_within_tolerance.</li> <li>It may change and diverge in the future, thus there are two separate functions.</li> </ul> Source code in <code>src/biotest/compare_files.py</code> <pre><code>def assert_two_pdb_files_within_tolerance(\n    file1: str | PathLike | IOBase, file2: str | PathLike | IOBase, *, tolerance=1e-3\n):\n    \"\"\"\n    Assert that two pdb files are equal under following conditions.\n\n    - ignore the trailing whitespace.\n    - 0.001 default tolerance for Orthogonal coordinates for X,Y,Z in Angstroms.\n\n    Note:\n        - Currently, the implementation is completely equal to assert_two_pdbqt_files_within_tolerance.\n        - It may change and diverge in the future, thus there are two separate functions.\n    \"\"\"\n    # ATOM    998  N   PHE B   9      18.937-159.292 -13.075  1.00 30.49           N\n    assert_two_pdbqt_files_within_tolerance(file1, file2, tolerance)\n</code></pre>"},{"location":"reference/biotest/compare_files/#biotest.compare_files.assert_two_dirs_within_tolerance","title":"<code>assert_two_dirs_within_tolerance(dir1, dir2, *, tolerance=0.001, filenames_exclude=None)</code>","text":"<p>Assert that two directories have the same files with almost the same content within tolerance.</p> Source code in <code>src/biotest/compare_files.py</code> <pre><code>def assert_two_dirs_within_tolerance(\n    dir1: str | PathLike,\n    dir2: str | PathLike,\n    *,\n    tolerance: float = 1e-3,\n    filenames_exclude: Sequence[str] | None = None,\n):\n    \"\"\"\n    Assert that two directories have the same files with almost the same content within tolerance.\n    \"\"\"\n    dir1 = Path(dir1)\n    dir2 = Path(dir2)\n    assert dir1.is_dir()\n    assert dir2.is_dir()\n\n    if filenames_exclude is None:\n        assert {path.name for path in dir1.iterdir()} == {\n            path.name for path in dir2.iterdir()\n        }\n    else:\n        assert {\n            path.name for path in dir1.iterdir() if path.name not in filenames_exclude\n        } == {\n            path.name for path in dir2.iterdir() if path.name not in filenames_exclude\n        }\n\n    for file1 in dir1.iterdir():\n        if filenames_exclude and file1.name in filenames_exclude:\n            continue\n\n        file2 = dir2 / file1.name\n\n        if file1.suffix == \".npy\":\n            assert_two_npys_within_tolerance(file1, file2, tolerance=tolerance)\n        elif file1.suffix == \".pdbqt\":\n            assert_two_pdbqt_files_within_tolerance(file1, file2, tolerance=tolerance)\n        elif file1.suffix == \".pdb\":\n            assert_two_pdb_files_within_tolerance(file1, file2, tolerance=tolerance)\n        elif file1.is_dir():\n            assert_two_dirs_within_tolerance(\n                file1, file2, tolerance=tolerance, filenames_exclude=filenames_exclude\n            )\n        else:\n            assert_two_files_equal_sha(file1, file2)\n</code></pre>"},{"location":"reference/biotest/cli/","title":"Index","text":""},{"location":"reference/biotest/cli/main/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> main","text":""},{"location":"reference/biotest/utils/","title":"Index","text":""},{"location":"reference/biotest/utils/#biotest.utils.setup_logging","title":"<code>setup_logging(console_level=default_log_level, log_dir=None, output_files=None, file_levels=None)</code>","text":"<p>Setup logging with RichHandler and FileHandler.</p> <p>You should call this function at the beginning of your script.</p> <p>Parameters:</p> Name Type Description Default <code>console_level</code> <code>int | str</code> <p>Logging level for console. Defaults to INFO or env var MLPROJECT_LOG_LEVEL.</p> <code>default_log_level</code> <code>log_dir</code> <code>str | PathLike | None</code> <p>Directory to save log files. If None, do not save log files.</p> <code>None</code> <code>output_files</code> <code>list[str] | None</code> <p>List of output file paths, relative to log_dir. If None, use default.</p> <code>None</code> <code>file_levels</code> <code>list[int] | None</code> <p>List of logging levels for each output file. If None, use default.</p> <code>None</code> Source code in <code>src/biotest/utils/log.py</code> <pre><code>def setup_logging(\n    console_level: int | str = default_log_level,\n    log_dir: str | PathLike | None = None,\n    output_files: list[str] | None = None,\n    file_levels: list[int] | None = None,\n):\n    \"\"\"\n    Setup logging with RichHandler and FileHandler.\n\n    You should call this function at the beginning of your script.\n\n    Args:\n        console_level: Logging level for console. Defaults to INFO or env var MLPROJECT_LOG_LEVEL.\n        log_dir: Directory to save log files. If None, do not save log files.\n        output_files: List of output file paths, relative to log_dir. If None, use default.\n        file_levels: List of logging levels for each output file. If None, use default.\n    \"\"\"\n    if log_dir is None:\n        assert output_files is None, \"output_files must be None if log_dir is None\"\n        assert file_levels is None, \"file_levels must be None if log_dir is None\"\n\n        output_files = []\n        file_levels = []\n    else:\n        log_dir = Path(log_dir)\n\n        if output_files is None:\n            output_files = [\"{date:%Y%m%d-%H%M%S}-{name}-{levelname}-{version}.log\"]\n        if file_levels is None:\n            file_levels = [logging.INFO]\n\n    assert len(output_files) == len(\n        file_levels\n    ), \"output_files and file_levels must have the same length\"\n\n    # NOTE: Initialise with NOTSET level and null device, and add stream handler separately.\n    # This way, the root logging level is NOTSET (log all), and we can customise each handler's behaviour.\n    # If we set the level during the initialisation, it will affect to ALL streams,\n    # so the file stream cannot be more verbose (lower level) than the console stream.\n    logging.basicConfig(\n        format=\"\",\n        level=logging.NOTSET,\n        stream=open(os.devnull, \"w\"),  # noqa: SIM115\n    )\n\n    # If you want to suppress logs from other modules, set their level to WARNING or higher\n    # logging.getLogger('slowfast.utils.checkpoint').setLevel(logging.WARNING)\n\n    console_handler = RichHandler(\n        level=console_level,\n        show_time=True,\n        show_level=True,\n        show_path=True,\n        rich_tracebacks=True,\n        tracebacks_show_locals=True,\n        console=console,\n    )\n    console_format = logging.Formatter(\n        fmt=\"%(name)s - %(message)s\",\n        datefmt=\"%m/%d %H:%M:%S\",\n    )\n    console_handler.setFormatter(console_format)\n\n    f_format = logging.Formatter(\n        fmt=\"%(asctime)s - %(name)s: %(lineno)4d - %(levelname)s - %(message)s\",\n        datefmt=\"%y/%m/%d %H:%M:%S\",\n    )\n\n    function_caller_module = inspect.getmodule(inspect.stack()[1][0])\n    if function_caller_module is None:\n        name_or_path = \"unknown\"\n    elif function_caller_module.__name__ == \"__main__\":\n        if function_caller_module.__file__ is None:\n            name_or_path = function_caller_module.__name__\n        else:\n            name_or_path = function_caller_module.__file__.replace(\n                str(PROJECT_DIR) + \"/\", \"\"\n            ).replace(\"/\", \".\")\n            # Remove .py extension\n            name_or_path = Path(name_or_path).with_suffix(\"\")\n\n    else:\n        name_or_path = function_caller_module.__name__\n\n    log_path_map = {\n        \"name\": name_or_path,\n        \"version\": __version__,\n        \"date\": datetime.now(timezone.utc),\n    }\n\n    root_logger = logging.getLogger()\n    root_logger.addHandler(console_handler)\n\n    log_paths = []\n    for output_file, file_level in zip(output_files, file_levels, strict=True):\n        log_path_map[\"levelname\"] = logging.getLevelName(file_level)\n        log_path = LOG_DIR / output_file.format_map(log_path_map)\n        log_path.parent.mkdir(parents=True, exist_ok=True)\n\n        f_handler = logging.FileHandler(log_path)\n        f_handler.setLevel(file_level)\n        f_handler.setFormatter(f_format)\n\n        # Add handlers to the logger\n        root_logger.addHandler(f_handler)\n\n    logger.info(f\"biotest {__version__}\")\n\n    for log_path in log_paths:\n        logger.info(f\"Logging to {log_path}\")\n</code></pre>"},{"location":"reference/biotest/utils/config/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> config","text":""},{"location":"reference/biotest/utils/config/#biotest.utils.config.BaseConfig","title":"<code>BaseConfig</code>  <code>dataclass</code>","text":"Source code in <code>src/biotest/utils/config.py</code> <pre><code>@dataclass\nclass BaseConfig:\n    @property\n    def envvar_prefix(self) -&gt; str:\n        return \"MLCONFIG_\"\n\n    def __post_init__(self):\n        self.verify_unknown_env_vars()\n        self.update_based_on_env_vars()\n        self.confirm_validity()\n\n    def update_based_on_env_vars(self):\n        import os\n        from dataclasses import fields\n        from types import NoneType, UnionType\n        from typing import get_args, get_origin\n\n        from rich.console import Console\n\n        # NOTE: without soft wrapping, it will line break depending on the width of the terminal.\n        # Which may cause the failure of the doctest.\n        console = Console(soft_wrap=True)\n\n        # for key, value in asdict(self).items():\n        for class_field in fields(self):\n            key = class_field.name\n            vartype = class_field.type\n\n            env_var = os.getenv(f\"{self.envvar_prefix}{key}\")\n            if env_var:\n                if get_origin(vartype) is UnionType:\n                    # If the type is Union, we use the first type\n                    # unless the value is None.\n                    if NoneType in get_args(vartype) and env_var == \"None\":\n                        setattr(self, key, None)\n\n                        console.print(\n                            f\"{type(self).__name__}: Updating {key} from env var \"\n                            f\"{self.envvar_prefix}{key}=None as NoneType\"\n                        )\n                    else:\n                        self._set_value_as_type(key, env_var, get_args(vartype)[0])\n                else:\n                    self._set_value_as_type(key, env_var, vartype)\n\n    def _set_value_as_type(self, key, value: str, vartype):\n        \"\"\"Set the string value as the given type.\"\"\"\n        import ast\n        from typing import get_origin\n\n        from rich.console import Console\n\n        if get_origin(vartype) is list:\n            setattr(self, key, ast.literal_eval(value))\n            assert isinstance(\n                getattr(self, key), vartype\n            ), f\"{type(self).__name__}.{key} has to be {vartype} but got {type(getattr(self, key))}\"\n        elif vartype is bool:\n            if value == \"True\":\n                setattr(self, key, True)\n            elif value == \"False\":\n                setattr(self, key, False)\n            else:\n                raise ValueError(\n                    f\"{type(self).__name__}: Unknown boolean value for {key}={value} trying to update from env var\"\n                )\n        else:\n            setattr(self, key, vartype(value))\n\n        console = Console(soft_wrap=True)\n        console.print(\n            f\"{type(self).__name__}: Updating {key} from env var \"\n            f\"{self.envvar_prefix}{key}={value} as type {vartype}\"\n        )\n\n    def print_fields(self):\n        from dataclasses import fields\n\n        from rich.console import Console\n\n        console = Console(soft_wrap=True)\n\n        console.print(f\"{type(self).__name__}: Fields:\")\n        for fld in fields(self):\n            console.print(f\"{fld.name}: {fld.type} = {fld.default!r}\")\n\n    def verify_unknown_env_vars(self):\n        import os\n        from dataclasses import asdict\n\n        # os.environ.keys() is always uppercase\n        for name, value in os.environ.items():\n            keys_lower = [k.lower() for k in asdict(self)]\n            if (\n                name.startswith(self.envvar_prefix)\n                and name[len(self.envvar_prefix) :].lower() not in keys_lower\n            ):\n                print(f\"ERROR while updating from env var {name}\")\n                print(\"Possible values are:\")\n                print()\n                self.print_fields()\n                raise ValueError(f\"Unknown environment variable {name}={value}\")\n\n    def confirm_validity(self):\n        pass\n</code></pre>"},{"location":"reference/biotest/utils/config/#biotest.utils.config.ExampleConfig","title":"<code>ExampleConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>BaseConfig \uc0ac\uc6a9\ubc95 \uc608: BaseConfig\ub97c inherit\ud574\uc11c \ubcc0\uc218, \ud0c0\uc785, default\uac12\uc744 \uc801\uc73c\uba74 \ub429\ub2c8\ub2e4.</p> <p><code>envvar_prefix</code> \ud568\uc218\ub97c override\ud574\uc11c \ud658\uacbd\ubcc0\uc218 prefix\ub97c \uc815\uc758\ud558\uace0, \ud658\uacbd\ubcc0\uc218\ub97c \uc774\uc6a9\ud574 \ubaa8\ub4e0 \uac12\uc744 \uc218\uc815\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cfg = ExampleConfig()\n&gt;&gt;&gt; cfg\nExampleConfig(train_batch_size=1, alpha=None)\n</code></pre> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ['MLCONFIG_train_batch_size'] = '2'\n&gt;&gt;&gt; ExampleConfig()\nExampleConfig: Updating train_batch_size from env var MLCONFIG_train_batch_size=2 as type &lt;class 'int'&gt;\nExampleConfig(train_batch_size=2, alpha=None)\n</code></pre> <pre><code>&gt;&gt;&gt; os.environ['MLCONFIG_alpha'] = '0.5'\n&gt;&gt;&gt; ExampleConfig()\nExampleConfig: Updating train_batch_size from env var MLCONFIG_train_batch_size=2 as type &lt;class 'int'&gt;\nExampleConfig: Updating alpha from env var MLCONFIG_alpha=0.5 as type &lt;class 'float'&gt;\nExampleConfig(train_batch_size=2, alpha=0.5)\n</code></pre> <pre><code>&gt;&gt;&gt; # Setting alpha to None with the string \"None\"\n&gt;&gt;&gt; os.environ['MLCONFIG_alpha'] = 'None'\n&gt;&gt;&gt; ExampleConfig()\nExampleConfig: Updating train_batch_size from env var MLCONFIG_train_batch_size=2 as type &lt;class 'int'&gt;\nExampleConfig: Updating alpha from env var MLCONFIG_alpha=None as NoneType\nExampleConfig(train_batch_size=2, alpha=None)\n</code></pre> <pre><code>&gt;&gt;&gt; # Undefined name in environment variable. Maybe a typo?\n&gt;&gt;&gt; os.environ['MLCONFIG_unknown'] = '1'\n&gt;&gt;&gt; ExampleConfig()\nTraceback (most recent call last):\n ...\nValueError: Unknown environment variable MLCONFIG_unknown=1\n</code></pre> Source code in <code>src/biotest/utils/config.py</code> <pre><code>@dataclass\nclass ExampleConfig(BaseConfig):\n    \"\"\"\n    BaseConfig \uc0ac\uc6a9\ubc95 \uc608: BaseConfig\ub97c inherit\ud574\uc11c \ubcc0\uc218, \ud0c0\uc785, default\uac12\uc744 \uc801\uc73c\uba74 \ub429\ub2c8\ub2e4.\n\n    `envvar_prefix` \ud568\uc218\ub97c override\ud574\uc11c \ud658\uacbd\ubcc0\uc218 prefix\ub97c \uc815\uc758\ud558\uace0,\n    \ud658\uacbd\ubcc0\uc218\ub97c \uc774\uc6a9\ud574 \ubaa8\ub4e0 \uac12\uc744 \uc218\uc815\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n    Examples:\n        &gt;&gt;&gt; cfg = ExampleConfig()\n        &gt;&gt;&gt; cfg\n        ExampleConfig(train_batch_size=1, alpha=None)\n\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; os.environ['MLCONFIG_train_batch_size'] = '2'\n        &gt;&gt;&gt; ExampleConfig()\n        ExampleConfig: Updating train_batch_size from env var MLCONFIG_train_batch_size=2 as type &lt;class 'int'&gt;\n        ExampleConfig(train_batch_size=2, alpha=None)\n\n        &gt;&gt;&gt; os.environ['MLCONFIG_alpha'] = '0.5'\n        &gt;&gt;&gt; ExampleConfig()\n        ExampleConfig: Updating train_batch_size from env var MLCONFIG_train_batch_size=2 as type &lt;class 'int'&gt;\n        ExampleConfig: Updating alpha from env var MLCONFIG_alpha=0.5 as type &lt;class 'float'&gt;\n        ExampleConfig(train_batch_size=2, alpha=0.5)\n\n        &gt;&gt;&gt; # Setting alpha to None with the string \"None\"\n        &gt;&gt;&gt; os.environ['MLCONFIG_alpha'] = 'None'\n        &gt;&gt;&gt; ExampleConfig()\n        ExampleConfig: Updating train_batch_size from env var MLCONFIG_train_batch_size=2 as type &lt;class 'int'&gt;\n        ExampleConfig: Updating alpha from env var MLCONFIG_alpha=None as NoneType\n        ExampleConfig(train_batch_size=2, alpha=None)\n\n        &gt;&gt;&gt; # Undefined name in environment variable. Maybe a typo?\n        &gt;&gt;&gt; os.environ['MLCONFIG_unknown'] = '1'\n        &gt;&gt;&gt; ExampleConfig()\n        Traceback (most recent call last):\n         ...\n        ValueError: Unknown environment variable MLCONFIG_unknown=1\n    \"\"\"\n\n    train_batch_size: int = 1\n    alpha: float | None = None\n\n    @property\n    def envvar_prefix(self) -&gt; str:\n        return \"MLCONFIG_\"\n</code></pre>"},{"location":"reference/biotest/utils/log/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> log","text":""},{"location":"reference/biotest/utils/log/#biotest.utils.log.setup_logging","title":"<code>setup_logging(console_level=default_log_level, log_dir=None, output_files=None, file_levels=None)</code>","text":"<p>Setup logging with RichHandler and FileHandler.</p> <p>You should call this function at the beginning of your script.</p> <p>Parameters:</p> Name Type Description Default <code>console_level</code> <code>int | str</code> <p>Logging level for console. Defaults to INFO or env var MLPROJECT_LOG_LEVEL.</p> <code>default_log_level</code> <code>log_dir</code> <code>str | PathLike | None</code> <p>Directory to save log files. If None, do not save log files.</p> <code>None</code> <code>output_files</code> <code>list[str] | None</code> <p>List of output file paths, relative to log_dir. If None, use default.</p> <code>None</code> <code>file_levels</code> <code>list[int] | None</code> <p>List of logging levels for each output file. If None, use default.</p> <code>None</code> Source code in <code>src/biotest/utils/log.py</code> <pre><code>def setup_logging(\n    console_level: int | str = default_log_level,\n    log_dir: str | PathLike | None = None,\n    output_files: list[str] | None = None,\n    file_levels: list[int] | None = None,\n):\n    \"\"\"\n    Setup logging with RichHandler and FileHandler.\n\n    You should call this function at the beginning of your script.\n\n    Args:\n        console_level: Logging level for console. Defaults to INFO or env var MLPROJECT_LOG_LEVEL.\n        log_dir: Directory to save log files. If None, do not save log files.\n        output_files: List of output file paths, relative to log_dir. If None, use default.\n        file_levels: List of logging levels for each output file. If None, use default.\n    \"\"\"\n    if log_dir is None:\n        assert output_files is None, \"output_files must be None if log_dir is None\"\n        assert file_levels is None, \"file_levels must be None if log_dir is None\"\n\n        output_files = []\n        file_levels = []\n    else:\n        log_dir = Path(log_dir)\n\n        if output_files is None:\n            output_files = [\"{date:%Y%m%d-%H%M%S}-{name}-{levelname}-{version}.log\"]\n        if file_levels is None:\n            file_levels = [logging.INFO]\n\n    assert len(output_files) == len(\n        file_levels\n    ), \"output_files and file_levels must have the same length\"\n\n    # NOTE: Initialise with NOTSET level and null device, and add stream handler separately.\n    # This way, the root logging level is NOTSET (log all), and we can customise each handler's behaviour.\n    # If we set the level during the initialisation, it will affect to ALL streams,\n    # so the file stream cannot be more verbose (lower level) than the console stream.\n    logging.basicConfig(\n        format=\"\",\n        level=logging.NOTSET,\n        stream=open(os.devnull, \"w\"),  # noqa: SIM115\n    )\n\n    # If you want to suppress logs from other modules, set their level to WARNING or higher\n    # logging.getLogger('slowfast.utils.checkpoint').setLevel(logging.WARNING)\n\n    console_handler = RichHandler(\n        level=console_level,\n        show_time=True,\n        show_level=True,\n        show_path=True,\n        rich_tracebacks=True,\n        tracebacks_show_locals=True,\n        console=console,\n    )\n    console_format = logging.Formatter(\n        fmt=\"%(name)s - %(message)s\",\n        datefmt=\"%m/%d %H:%M:%S\",\n    )\n    console_handler.setFormatter(console_format)\n\n    f_format = logging.Formatter(\n        fmt=\"%(asctime)s - %(name)s: %(lineno)4d - %(levelname)s - %(message)s\",\n        datefmt=\"%y/%m/%d %H:%M:%S\",\n    )\n\n    function_caller_module = inspect.getmodule(inspect.stack()[1][0])\n    if function_caller_module is None:\n        name_or_path = \"unknown\"\n    elif function_caller_module.__name__ == \"__main__\":\n        if function_caller_module.__file__ is None:\n            name_or_path = function_caller_module.__name__\n        else:\n            name_or_path = function_caller_module.__file__.replace(\n                str(PROJECT_DIR) + \"/\", \"\"\n            ).replace(\"/\", \".\")\n            # Remove .py extension\n            name_or_path = Path(name_or_path).with_suffix(\"\")\n\n    else:\n        name_or_path = function_caller_module.__name__\n\n    log_path_map = {\n        \"name\": name_or_path,\n        \"version\": __version__,\n        \"date\": datetime.now(timezone.utc),\n    }\n\n    root_logger = logging.getLogger()\n    root_logger.addHandler(console_handler)\n\n    log_paths = []\n    for output_file, file_level in zip(output_files, file_levels, strict=True):\n        log_path_map[\"levelname\"] = logging.getLevelName(file_level)\n        log_path = LOG_DIR / output_file.format_map(log_path_map)\n        log_path.parent.mkdir(parents=True, exist_ok=True)\n\n        f_handler = logging.FileHandler(log_path)\n        f_handler.setLevel(file_level)\n        f_handler.setFormatter(f_format)\n\n        # Add handlers to the logger\n        root_logger.addHandler(f_handler)\n\n    logger.info(f\"biotest {__version__}\")\n\n    for log_path in log_paths:\n        logger.info(f\"Logging to {log_path}\")\n</code></pre>"}]}